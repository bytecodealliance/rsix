[package]
name = "rustix"
version = "0.33.2"
authors = [
    "Dan Gohman <dev@sunfishcode.online>",
    "Jakub Konka <kubkon@jakubkonka.com>",
]
description = "Safe Rust bindings to POSIX/Unix/Linux/Winsock2-like syscalls"
documentation = "https://docs.rs/rustix"
license = "Apache-2.0 WITH LLVM-exception OR Apache-2.0 OR MIT"
repository = "https://github.com/bytecodealliance/rustix"
edition = "2018"
keywords = ["api", "file", "network", "safe", "syscall"]
categories = ["os::unix-apis", "date-and-time", "filesystem", "network-programming"]
exclude = ["/.*"]

[build-dependencies]
cc = { version = "1.0.68", optional = true }

[dependencies]
bitflags = "1.2.1"
itoa = { version = "1.0.1", default-features = false, optional = true }
io-lifetimes = { version = "0.5.1", default-features = false, optional = true }

# Special dependencies used in rustc-dep-of-std mode.
core = { version = "1.0.0", optional = true, package = "rustc-std-workspace-core" }
alloc = { version = "1.0.0", optional = true, package = "rustc-std-workspace-alloc" }
compiler_builtins = { version = '0.1.49', optional = true }

# The procfs feature needs once_cell.
[target.'cfg(any(target_os = "android", target_os = "linux"))'.dependencies]
once_cell = { version = "1.5.2", optional = true }

# For the linux_raw backend, linux-raw-sys provides Linux ABI details.
linux-raw-sys = { version = "0.0.40", default-features = false, features = ["general", "errno", "ioctl", "no_std"], optional = true }

# For the libc backend on Unix platforms, use the libc crate, and errno for
# setting `errno`.  Don't try to enable these directly; instead, enable
# via `use-libc` feature.
[target.'cfg(target_os = "linux")'.dependencies]
# Keep these in sync with the non-Linux case below
errno = { version = "0.2.8", default-features = false, optional = true }
libc = { version = "0.2.114", features = ["extra_traits"], optional = true }

# libc/errno are hard required on non-Linux
[target.'cfg(not(target_os = "linux"))'.dependencies]
errno = { version = "0.2.8", default-features = false }
libc = { version = "0.2.114", features = ["extra_traits"] }

# For the libc backend on Windows, use the Winsock2 API in winapi.
[target.'cfg(windows)'.dependencies]
winapi = { version = "0.3.9", features = ["ws2ipdef", "ws2tcpip"] }

[dev-dependencies]
is-terminal = "0.1.0"
tempfile = "3.2.0"
libc = "0.2.114"
serial_test = "0.5"

[target.'cfg(not(target_os = "emscripten"))'.dev-dependencies]
criterion = "0.3"

[target.'cfg(windows)'.dev-dependencies]
ctor = "0.1.21"

[features]
default = ["std", "backend-linux-raw"]
std = ["io-lifetimes"]
rustc-dep-of-std-core = [
    "core",
    "alloc",
    "compiler_builtins",
    "bitflags/rustc-dep-of-std",
]
rustc-dep-of-std-libc = [
    "libc/rustc-dep-of-std",
]
rustc-dep-of-std-libc-linux-raw-sys = [
    "linux-raw-sys/rustc-dep-of-std",
]
# Enable this to perform system calls via libc.
backend-libc = ["errno", "libc"]
# Enable this to perform system calls directly.
# Note that if both `backend-linux-raw` and `backend-libc` are set,
# then `backend-libc` takes precedence.
backend-linux-raw = ["linux-raw-sys"]

# Enable this to enable `proc_self_fd` (on Linux) and `ttyname`.
procfs = ["once_cell", "itoa"]

# Expose io-lifetimes' features for third-party crate impls.
async-std = ["io-lifetimes/async-std"]
tokio = ["io-lifetimes/tokio"]
os_pipe = ["io-lifetimes/os_pipe"]
socket2 = ["io-lifetimes/socket2"]
mio = ["io-lifetimes/mio"]
fs-err = ["io-lifetimes/fs-err"]
all-impls = ["async-std", "tokio", "os_pipe", "socket2", "mio", "fs-err"]

# Add Criterion configuration, as described here:
# <https://bheisler.github.io/criterion.rs/book/getting_started.html#step-1---add-dependency-to-cargotoml>
[[bench]]
name = "mod"
harness = false

[package.metadata.docs.rs]
features = ["procfs"]
rustdoc-args = ["--cfg", "doc_cfg"]
targets = [
    "x86_64-unknown-linux-gnu",
    "i686-unknown-linux-gnu",
    "x86_64-apple-darwin",
    "x86_64-pc-windows-msvc",
]
